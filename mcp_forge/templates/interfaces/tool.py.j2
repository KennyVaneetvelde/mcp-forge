"""Interfaces for tool abstractions."""
from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional, ClassVar, Type, get_type_hints, Union, Generic, TypeVar
from pydantic import BaseModel, Field, create_model

# Define a type variable for generic model support
T = TypeVar('T', bound=BaseModel)

class BaseToolInput(BaseModel):
    """Base class for tool input models."""
    model_config = {"extra": "forbid"}  # Equivalent to additionalProperties: false


class ToolContent(BaseModel):
    """Model for content in tool responses."""
    type: str = Field(default="text", description="Content type identifier")

    # Common fields for all content types
    content_id: Optional[str] = Field(None, description="Optional content identifier")

    # Type-specific fields (using discriminated unions pattern)
    # Text content
    text: Optional[str] = Field(None, description="Text content when type='text'")

    # JSON content (for structured data)
    json_data: Optional[Dict[str, Any]] = Field(None, description="JSON data when type='json'")

    # Model content (will be converted to json_data during serialization)
    model: Optional[Any] = Field(None, exclude=True, description="Pydantic model instance")

    # Resource link content (MCP 2025-06-18)
    uri: Optional[str] = Field(None, description="Resource URI when type='resource_link'")
    title: Optional[str] = Field(None, description="Optional resource title for resource_link")

    # Add more content types as needed (e.g., binary, image, audio, etc.)

    def model_post_init(self, __context: Any) -> None:
        """Post-initialization hook to handle model conversion."""
        if self.model and not self.json_data:
            # Convert model to json_data
            if isinstance(self.model, BaseModel):
                self.json_data = self.model.model_dump()
                if not self.type or self.type == "text":
                    self.type = "json"


class ToolResponse(BaseModel):
    """Model for tool responses."""
    content: List[ToolContent]

    @classmethod
    def from_model(cls, model: BaseModel) -> "ToolResponse":
        """Create a ToolResponse from a Pydantic model.

        This makes it easier to return structured data directly.

        Args:
            model: A Pydantic model instance to convert

        Returns:
            A ToolResponse with the model data in JSON format
        """
        return cls(
            content=[
                ToolContent(
                    type="json",
                    json_data=model.model_dump(),
                    model=model
                )
            ]
        )

    @classmethod
    def from_text(cls, text: str) -> "ToolResponse":
        """Create a ToolResponse from plain text.

        Args:
            text: The text content

        Returns:
            A ToolResponse with text content
        """
        return cls(
            content=[
                ToolContent(
                    type="text",
                    text=text
                )
            ]
        )

    @classmethod
    def from_resource_link(cls, uri: str, title: Optional[str] = None, description: Optional[str] = None) -> "ToolResponse":
        """Create a ToolResponse that links to an MCP resource.

        This is useful when a tool wants to reference data in a resource
        rather than returning it inline. Introduced in MCP spec 2025-06-18.

        Args:
            uri: The MCP resource URI (e.g., "resource://data/analysis-123")
            title: Optional human-readable title for the resource
            description: Optional description text to accompany the link

        Returns:
            A ToolResponse with a resource link

        Example:
            return ToolResponse.from_resource_link(
                uri="resource://analysis/2024-01-report",
                title="2024 Analysis Report",
                description="The analysis has been saved as a resource"
            )
        """
        content_items = []

        # Add description as text if provided
        if description:
            content_items.append(
                ToolContent(
                    type="text",
                    text=description
                )
            )

        # Add resource link
        content_items.append(
            ToolContent(
                type="resource_link",
                uri=uri,
                title=title
            )
        )

        return cls(content=content_items)


class Tool(ABC):
    """Abstract base class for all tools."""
    name: ClassVar[str]
    description: ClassVar[str]
    input_model: ClassVar[Type[BaseToolInput]]
    output_model: ClassVar[Optional[Type[BaseModel]]] = None

    @abstractmethod
    async def execute(self, input_data: BaseToolInput) -> ToolResponse:
        """Execute the tool with given arguments."""
        pass

    def get_schema(self) -> Dict[str, Any]:
        """Get JSON schema for the tool."""
        schema = {
            "name": self.name,
            "description": self.description,
            "input": self.input_model.model_json_schema(),
        }

        if self.output_model:
            schema["output"] = self.output_model.model_json_schema()

        return schema
