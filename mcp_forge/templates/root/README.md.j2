# {{ config.project_name }}

{{ config.description }}

This MCP (Model Context Protocol) server was generated by `mcp-forge` and provides a modern implementation following the latest MCP specifications (2025-06-18).

## Features

- ‚úÖ **Modern Transports**: {% if config.transport == "both" %}Both stdio and Streamable HTTP{% elif config.transport == "http" %}Streamable HTTP{% else %}stdio{% endif %} transport support
- üõ†Ô∏è **Tools**: Execute actions with validated inputs and outputs
- üì¶ **Resources**: Serve static and dynamic content
{% if config.with_prompts -%}
- üí¨ **Prompts**: Reusable message templates for LLM interactions
{% endif -%}
{% if config.with_sampling -%}
- ü§ñ **Sampling**: AI-to-AI collaboration support
{% endif -%}
{% if config.with_elicitation -%}
- üôã **Elicitation**: Request user input during tool execution (MCP 2025-06-18)
{% endif -%}
- üöÄ **FastMCP 2.0**: Built on the standard Python MCP framework

## Project Structure

```
{{ config.project_name }}/
‚îú‚îÄ‚îÄ {{ config.package_name }}/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ server.py                # Unified server with transport selection
{% if config.transport in ["stdio", "both"] -%}
‚îÇ   ‚îú‚îÄ‚îÄ server_stdio.py          # stdio transport implementation
{% endif -%}
{% if config.transport in ["http", "both"] -%}
‚îÇ   ‚îú‚îÄ‚îÄ server_http.py           # Streamable HTTP transport
{% endif -%}
‚îÇ   ‚îú‚îÄ‚îÄ interfaces/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tool.py              # Tool base interface
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ resource.py          # Resource base interface
{% if config.with_prompts -%}
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ prompt.py            # Prompt base interface
{% endif -%}
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tool_service.py      # Tool management
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ resource_service.py  # Resource management
{% if config.with_prompts -%}
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ prompt_service.py    # Prompt management
{% endif -%}
‚îÇ   ‚îú‚îÄ‚îÄ tools/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ add_numbers.py       # Example: Math tool
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ date_difference.py   # Example: Date tool
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...                  # More example tools
‚îÇ   ‚îú‚îÄ‚îÄ resources/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hello_world.py       # Static resource example
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user_profile.py      # Dynamic resource example
{% if config.with_prompts -%}
‚îÇ   ‚îî‚îÄ‚îÄ prompts/
‚îÇ       ‚îú‚îÄ‚îÄ code_review.py       # Code review prompt
‚îÇ       ‚îú‚îÄ‚îÄ data_analysis.py     # Data analysis prompt
‚îÇ       ‚îî‚îÄ‚îÄ debug_assistant.py   # Debug assistant prompt
{% endif -%}
‚îú‚îÄ‚îÄ pyproject.toml               # Project dependencies
‚îî‚îÄ‚îÄ README.md                    # This file
```

## Setup

This project uses `uv` for fast, reliable dependency management.

```bash
# Navigate to project
cd {{ config.project_name }}

# Install dependencies (creates venv automatically)
uv sync
```

## Running the Server

### Unified Entry Point (Recommended)

```bash
# Run with stdio transport (for Claude Desktop, Cursor, etc.)
uv run -m {{ config.package_name }}.server --transport stdio

# Run with HTTP transport (for web deployments)
uv run -m {{ config.package_name }}.server --transport http

# Run with SSE transport
uv run -m {{ config.package_name }}.server --transport sse

# HTTP with development mode (auto-reload)
uv run -m {{ config.package_name }}.server --transport http --reload

# Custom host/port for HTTP
uv run -m {{ config.package_name }}.server --transport http --host 0.0.0.0 --port 8080
```

{% if config.transport in ["stdio", "both"] -%}
### Direct stdio Transport

```bash
uv run -m {{ config.package_name }}.server_stdio
```
{% endif %}

{% if config.transport in ["http", "both"] -%}
### Direct HTTP Transport

```bash
# Default: http://127.0.0.1:8000/mcp
uv run -m {{ config.package_name }}.server_http

# Custom configuration
uv run -m {{ config.package_name }}.server_http --host 0.0.0.0 --port 8080 --reload
```

The Streamable HTTP transport provides:
- Single `/mcp` endpoint for all operations
- Session management with secure IDs
- Bi-directional communication
- Compatible with web deployments
{% endif %}

## Development Guide

### Adding Tools

1. Create a new file in `{{ config.package_name }}/tools/`
2. Inherit from `Tool` interface
3. Define input model with Pydantic
4. Implement `execute` method
5. Register in `server.py`'s `get_available_tools()`

Example:
```python
from {{ config.package_name }}.interfaces.tool import Tool, ToolResponse, BaseToolInput
from pydantic import Field

class MyToolInput(BaseToolInput):
    param: str = Field(description="Tool parameter")

class MyTool(Tool):
    name = "my_tool"
    description = "Does something useful"
    input_model = MyToolInput

    async def execute(self, input_data: MyToolInput) -> ToolResponse:
        # Tool logic here
        return ToolResponse(...)
```

{% if config.with_elicitation -%}
### Adding Tools with Elicitation

Elicitation allows tools to request additional information from users during execution. This is part of the MCP 2025-06-18 specification.

#### Simple Scalar Elicitation

Request a single value (string, int, bool):

```python
from {{ config.package_name }}.interfaces.tool import Tool, ToolResponse, BaseToolInput
from fastmcp import Context

class GreetingTool(Tool):
    name = "greeting_tool"
    description = "Greets user by asking their name"
    input_model = BaseToolInput

    async def execute(self, input_data: BaseToolInput, ctx: Context) -> ToolResponse:
        # Request user's name
        result = await ctx.elicit("What's your name?", response_type=str)

        if result.action == "accept":
            return ToolResponse.from_text(f"Hello, {result.data}!")
        elif result.action == "decline":
            return ToolResponse.from_text("No problem!")
        else:  # cancelled
            return ToolResponse.from_text("Cancelled")
```

#### Structured Data Elicitation

Request multiple fields at once using Pydantic models:

```python
from pydantic import BaseModel, Field
from typing import Literal

class TaskDetails(BaseModel):
    title: str = Field(..., description="Task title")
    priority: Literal["low", "medium", "high"] = Field(..., description="Priority level")
    due_date: str = Field(..., description="Due date (YYYY-MM-DD)")

class TaskTool(Tool):
    name = "create_task"
    description = "Creates a task with user-provided details"
    input_model = BaseToolInput

    async def execute(self, input_data: BaseToolInput, ctx: Context) -> ToolResponse:
        result = await ctx.elicit(
            "Please provide task details:",
            response_type=TaskDetails
        )

        if result.action == "accept":
            task = result.data
            return ToolResponse.from_text(f"Created: {task.title} (Priority: {task.priority})")
        return ToolResponse.from_text("Task creation cancelled")
```

#### Multi-Turn Elicitation

Gather information step-by-step:

```python
class MeetingTool(Tool):
    name = "plan_meeting"
    description = "Plans a meeting by gathering details step-by-step"
    input_model = BaseToolInput

    async def execute(self, input_data: BaseToolInput, ctx: Context) -> ToolResponse:
        # Step 1: Get title
        title_result = await ctx.elicit("Meeting title?", response_type=str)
        if title_result.action != "accept":
            return ToolResponse.from_text("Cancelled")

        # Step 2: Get duration
        duration_result = await ctx.elicit("Duration (minutes)?", response_type=int)
        if duration_result.action != "accept":
            return ToolResponse.from_text("Cancelled")

        # Step 3: Get urgency
        urgent_result = await ctx.elicit("Urgent?", response_type=Literal["yes", "no"])
        if urgent_result.action != "accept":
            return ToolResponse.from_text("Cancelled")

        return ToolResponse.from_text(
            f"Meeting '{title_result.data}' planned for {duration_result.data} min"
        )
```

#### Approval/Confirmation

Request simple yes/no approval without collecting data:

```python
class ApprovalTool(Tool):
    name = "approve_action"
    description = "Requests user approval for an action"
    input_model = BaseToolInput

    async def execute(self, input_data: BaseToolInput, ctx: Context) -> ToolResponse:
        result = await ctx.elicit(
            "Do you approve this action?",
            response_type=None  # No data needed, just approval
        )

        if result.action == "accept":
            # Perform the approved action
            return ToolResponse.from_text("Action approved and executed!")
        return ToolResponse.from_text("Action not approved")
```

#### Important Notes on Elicitation

1. **Response Types**: Support scalar types (str, int, bool), Pydantic models, Literal types for enums, and None for approval-only
2. **Actions**: Handle all three actions - "accept", "decline", and "cancel"
3. **Flat Structures**: MCP spec only supports shallow objects with scalar/enum properties (no nested objects or arrays)
4. **Client Support**: Elicitation requires clients that implement the elicitation handler feature
5. **Security**: Never use elicitation to request sensitive information (passwords, API keys, etc.)

{% endif -%}
### Adding Resources

1. Create a new file in `{{ config.package_name }}/resources/`
2. Inherit from `Resource` interface
3. Define URI pattern (static or dynamic)
4. Implement `read` method
5. Register in `server.py`'s `get_available_resources()`

Example:
```python
from {{ config.package_name }}.interfaces.resource import Resource, ResourceResponse

class MyResource(Resource):
    name = "my_resource"
    description = "Serves content"
    uri = "resource://data/{id}"  # Dynamic URI
    mime_type = "application/json"
    
    async def read(self, id: str) -> ResourceResponse:
        # Resource logic here
        return ResourceResponse(...)
```

{% if config.with_prompts -%}
### Adding Prompts

1. Create a new file in `{{ config.package_name }}/prompts/`
2. Inherit from `Prompt` interface
3. Define arguments and generation logic
4. Register in `server.py`'s `get_available_prompts()`

Example:
```python
from {{ config.package_name }}.interfaces.prompt import Prompt, PromptMessage, PromptArgument

class MyPrompt(Prompt):
    @property
    def name(self) -> str:
        return "my_prompt"
    
    @property
    def description(self) -> str:
        return "Generates helpful prompts"
    
    async def generate(self, **kwargs) -> List[PromptMessage]:
        return [
            PromptMessage(role="user", content="..."),
            PromptMessage(role="assistant", content="...")
        ]
```
{% endif %}

## Testing Your Server

### Interactive Demo Client (Recommended)

The project includes a comprehensive demo client that showcases all MCP features:

```bash
# Interactive mode - explore tools, resources, and prompts via menu
python demo.py

# Automated testing mode - run comprehensive test suite
python demo.py --mode test

# Use SSE transport (server must be running separately)
python demo.py --transport sse
```

The demo client demonstrates:
- üîß All available tools with input validation
- üì¶ Resource reading (static and dynamic)
{% if config.with_prompts -%}
- üí¨ Prompt generation with arguments
{% endif -%}
- üìä Progress notifications and logging
- üîó Resource links in tool responses
{% if config.with_sampling -%}
- ü§ñ Sampling (AI-to-AI collaboration)
{% endif -%}
{% if config.with_elicitation -%}
- üôã Elicitation tools (requires client with elicitation support)
{% endif -%}

### MCP Inspector (Official Anthropic GUI Tool)

The MCP Inspector provides a browser-based GUI for testing your server:

```bash
# Install and run (one command)
npx @modelcontextprotocol/inspector -- uv run -m {{ config.package_name }}.server --transport stdio
```

This opens a web interface where you can:
- üìã Browse all tools, resources, and prompts
- ‚ñ∂Ô∏è Execute tools with a visual form interface
- üìñ Read resources and see their content
- üí¨ Generate prompts with arguments
- üì§ Export server configuration for Claude Desktop, Cursor, etc.

Learn more: [MCP Inspector Documentation](https://github.com/modelcontextprotocol/inspector)

### With Claude Desktop

1. Add to Claude Desktop config:
```json
{
  "mcpServers": {
    "{{ config.project_name }}": {
      "command": "uv",
      "args": ["run", "-m", "{{ config.package_name }}.server", "--transport", "stdio"]
    }
  }
}
```

2. Restart Claude Desktop

### With HTTP Client

```bash
# Start server
uv run -m {{ config.package_name }}.server --transport http

# Test with curl
curl -X POST http://localhost:8000/mcp \
  -H "Content-Type: application/json" \
  -d '{"jsonrpc": "2.0", "method": "initialize", "params": {}, "id": 1}'
```

## Configuration

{% if config.with_sampling -%}
### Sampling Support

This server has sampling capability enabled, allowing it to request completions from LLMs through the client. This enables sophisticated AI-to-AI collaboration patterns.
{% endif %}

{% if config.with_elicitation -%}
### Elicitation Support

This server has elicitation capability enabled (MCP spec 2025-06-18), allowing tools to request additional information from users during execution. Elicitation enables:

- **Interactive workflows**: Tools can ask for confirmation or additional details mid-execution
- **Dynamic data collection**: Gather user input based on runtime conditions
- **User-guided processes**: Multi-step workflows that adapt to user responses

**Example Tools Included:**
- `greeting_elicitation` - Simple scalar input (string)
- `task_creation_elicitation` - Structured data collection (Pydantic model)
- `meeting_planner_elicitation` - Multi-turn sequential collection
- `approval_elicitation` - Simple approval/confirmation

**Client Requirements:**
Elicitation requires MCP clients that implement the elicitation handler feature. Clients like Claude Desktop may support this feature. Check your client's documentation for elicitation support.

**Learn More:** [MCP Elicitation Specification](https://modelcontextprotocol.io/specification/2025-06-18/client/elicitation)
{% endif %}

### Environment Variables

- `MCP_LOG_LEVEL`: Set logging level (DEBUG, INFO, WARNING, ERROR)
- `MCP_HOST`: Override default host for HTTP transport
- `MCP_PORT`: Override default port for HTTP transport

## Resources

- [MCP Specification](https://modelcontextprotocol.io/specification)
- [FastMCP Documentation](https://gofastmcp.com)
- [MCP TypeScript SDK](https://github.com/modelcontextprotocol/typescript-sdk)
- [MCP Python SDK](https://github.com/modelcontextprotocol/python-sdk)

## License

This project was generated with mcp-forge. Add your license here.